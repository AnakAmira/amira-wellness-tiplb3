---
title: Android Deployment Guide
---

## Introduction
This document provides comprehensive instructions for deploying the Amira Wellness Android application to various environments. The Android app is built with Kotlin and Jetpack Compose, with a focus on privacy, security, and user experience.

The deployment process is automated through CI/CD pipelines, with appropriate safeguards and validation steps to ensure application quality and integrity. This guide covers all aspects of Android deployment, from development builds to Google Play Store distribution, including code signing, build configurations, and release management procedures.

The Amira Wellness Android application follows Google's best practices for deployment, with a focus on security, reliability, and user experience. The application is distributed through Firebase App Distribution for beta testing and the Google Play Store for production releases.

## Prerequisites
Before proceeding with deployment, ensure the following prerequisites are met:

### Access Requirements
- Google Play Developer account with appropriate access level
- Firebase project with App Distribution enabled
- GitHub repository access with write permissions
- Access to the signing keystore and credentials
- Google Cloud Storage access for build artifacts (optional)

### Tools and Software
- Android Studio Hedgehog (2023.1.1) or later
- JDK 17
- Gradle 8.1.0 or later
- Git for source code management
- GitHub CLI (optional, for release management)
- Firebase CLI (for App Distribution)

### Knowledge Requirements
- Basic understanding of Android app development and Gradle
- Familiarity with code signing and keystore management
- Understanding of Google Play submission process
- Knowledge of CI/CD principles and GitHub Actions
- Familiarity with Firebase App Distribution

## Code Signing
Code signing is a critical aspect of Android app deployment, ensuring the app's authenticity and integrity.

### Keystore Management
The Android app requires a keystore for signing:

- **Debug Keystore**: Used for development builds, automatically generated by Android Studio
- **Release Keystore**: Used for production builds, must be securely stored

The release keystore should be created once and used consistently for all production builds to ensure seamless updates for users.

### Creating a Keystore
If you need to create a new keystore for production (only needed once):

```bash
# Generate a new keystore
keytool -genkey -v -keystore amira-release-key.keystore -alias amira -keyalg RSA -keysize 2048 -validity 10000
```

Store the keystore file and password securely. The keystore should have a validity period of at least 25 years to cover the app's lifetime.

### Gradle Configuration
Configure signing in the app's `build.gradle.kts` file:

```kotlin
android {
    signingConfigs {
        create("release") {
            storeFile = file("../keystore/amira-release-key.keystore")
            storePassword = System.getenv("KEYSTORE_PASSWORD") ?: ""
            keyAlias = System.getenv("KEY_ALIAS") ?: "amira"
            keyPassword = System.getenv("KEY_PASSWORD") ?: ""
        }
    }
    
    buildTypes {
        getByName("release") {
            isMinifyEnabled = true
            isShrinkResources = true
            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
            signingConfig = signingConfigs.getByName("release")
        }
    }
}
```

For local development, store the keystore credentials in a local `keystore.properties` file that is not committed to version control.

### CI/CD Integration
In the CI/CD pipeline, the keystore and credentials are stored securely:

```yaml
# GitHub Actions workflow excerpt
- name: Decode Keystore
  run: |\
    echo ${{ secrets.KEYSTORE_BASE64 }} | base64 -d > keystore/amira-release-key.keystore

- name: Build Release APK
  run: ./gradlew assembleRelease
  env:
    KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
    KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
    KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}
```

This approach ensures secure handling of signing assets in the CI/CD environment.

### App Signing by Google Play
For additional security, enable Google Play App Signing:

1. Upload your app's signing key to Google Play
2. Google Play will use this key to sign the app for distribution
3. You'll use an upload key for submitting updates

This provides better security and enables features like Android App Bundles and Play Asset Delivery.

## Deployment Environments
The Amira Wellness Android application can be deployed to several environments, each with specific configurations and purposes:

### Development
Development builds are used for internal testing during feature development. These builds are typically installed directly from Android Studio or distributed via ADB.

Key characteristics:
- Debug signing configuration
- Debug build type
- Development API endpoint
- Debug logging enabled
- Test features enabled

To create a development build:

```bash
# Using Android Studio
# Open the project and select the 'debug' build variant
# Run on device or emulator

# Using Gradle
cd src/android
./gradlew assembleDebug
```

Development builds can be installed directly on devices using ADB:

```bash
adb install app/build/outputs/apk/debug/app-debug.apk
```

### Internal Testing (Firebase)
Internal testing builds are used for testing with team members and stakeholders before public beta or production release.

Key characteristics:
- Release signing configuration
- Debug or release build type with `.debug` suffix
- Staging API endpoint
- Limited logging
- Beta features enabled for testing

To create and distribute an internal testing build:

```bash
# Build the APK
cd src/android
./gradlew assembleDebug

# Distribute via Firebase App Distribution
firebase appdistribution:distribute app/build/outputs/apk/debug/app-debug.apk \
  --app [FIREBASE_APP_ID] \
  --groups "testers" \
  --release-notes "Internal testing build"
```

The CI/CD pipeline automates this process for builds from the `develop` branch.

### Beta Testing (Google Play)
Beta testing builds are used for wider testing with external users before production release.

Key characteristics:
- Release signing configuration
- Release build type
- Staging or production API endpoint
- Minimal logging
- Beta features enabled for testing

To create and distribute a beta testing build:

```bash
# Build the bundle
cd src/android
./gradlew bundleRelease

# Upload to Google Play Beta track
# This is typically done through the Google Play Console or using the Google Play Developer API
```

The CI/CD pipeline can automate this process for builds from the `release` branch.

### Production (Google Play)
Production builds are the public versions available to end users through the Google Play Store.

Key characteristics:
- Release signing configuration
- Release build type
- Production API endpoint
- Minimal logging
- Only stable features enabled

To create a production build:

```bash
# Build the bundle
cd src/android
./gradlew bundleRelease

# Upload to Google Play Production track
# This is typically done through the Google Play Console or using the Google Play Developer API
```

The CI/CD pipeline automates this process for builds from the `main` branch, with required approval.

## Build Configurations
The Android project includes multiple build configurations to support different deployment environments.

### Build Types
The project defines two main build types:

- **Debug**: For development and testing, with debugging enabled
- **Release**: For beta and production, with optimizations enabled

Configuration in `build.gradle.kts`:

```kotlin
android {
    buildTypes {
        debug {
            isMinifyEnabled = false
            applicationIdSuffix = ".debug"
            versionNameSuffix = "-debug"
            buildConfigField("String", "API_BASE_URL", "\"https://api-dev.amirawellness.com/\"")
            buildConfigField("Boolean", "ENABLE_LOGGING", "true")
        }
        release {
            isMinifyEnabled = true
            isShrinkResources = true
            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
            buildConfigField("String", "API_BASE_URL", "\"https://api.amirawellness.com/\"")
            buildConfigField("Boolean", "ENABLE_LOGGING", "false")
        }
    }
}
```

### Product Flavors
Product flavors can be used to create different versions of the app with specific configurations:

```kotlin
android {
    flavorDimensions += "environment"
    
    productFlavors {
        create("dev") {
            dimension = "environment"
            applicationIdSuffix = ".dev"
            versionNameSuffix = "-dev"
            buildConfigField("String", "API_BASE_URL", "\"https://api-dev.amirawellness.com/\"")
        }
        create("staging") {
            dimension = "environment"
            applicationIdSuffix = ".staging"
            versionNameSuffix = "-staging"
            buildConfigField("String", "API_BASE_URL", "\"https://api-staging.amirawellness.com/\"")
        }
        create("prod") {
            dimension = "environment"
            buildConfigField("String", "API_BASE_URL", "\"https://api.amirawellness.com/\"")
        }
    }
}
```

This creates build variants like `devDebug`, `stagingDebug`, `prodRelease`, etc.

### Build Configuration Fields
BuildConfig fields provide compile-time configuration:

```kotlin
buildConfigField("String", "API_BASE_URL", "\"https://api.amirawellness.com/\"")
buildConfigField("Boolean", "ENABLE_LOGGING", "false")
buildConfigField("String", "PRIVACY_POLICY_URL", "\"https://amirawellness.com/privacy\"")
buildConfigField("String", "TERMS_URL", "\"https://amirawellness.com/terms\"")
```

These values are accessible in code via the `BuildConfig` class:

```kotlin
val apiBaseUrl = BuildConfig.API_BASE_URL
val isLoggingEnabled = BuildConfig.ENABLE_LOGGING
```

### Resource Configuration
Different resources can be provided for different build variants using resource directories:

```
src/
  main/res/       # Common resources
  debug/res/      # Debug-specific resources
  release/res/    # Release-specific resources
  dev/res/        # Dev flavor resources
  staging/res/    # Staging flavor resources
  prod/res/       # Production flavor resources
```

This allows for environment-specific strings, colors, or other resources.

### Feature Flags
Feature flags enable or disable features in different environments:

```kotlin
object FeatureFlags {
    val isNewRecommendationEngineEnabled: Boolean
        get() = when {
            BuildConfig.DEBUG -> true
            BuildConfig.FLAVOR == "dev" -> true
            BuildConfig.FLAVOR == "staging" -> true
            else -> false
        }
    
    val isAdvancedAnalyticsEnabled: Boolean
        get() = !BuildConfig.DEBUG && BuildConfig.FLAVOR == "prod"
    
    val isVoiceEffectsEnabled: Boolean
        get() = BuildConfig.DEBUG || BuildConfig.FLAVOR != "prod"
}
```

This approach allows for controlled feature rollout and testing.

## CI/CD Pipeline
The CI/CD pipeline automates the build, test, and deployment process, ensuring consistent and reliable deployments.

### GitHub Actions Workflow
The CI/CD pipeline is implemented using GitHub Actions, with separate workflows for different purposes:

- `android-ci.yml`: Runs tests and builds the app on pull requests and pushes
- `deploy-staging.yml`: Deploys to Firebase App Distribution for internal testing
- `deploy-production.yml`: Deploys to Google Play with approval

These workflows are defined in the `.github/workflows` directory.

### CI Workflow
The CI workflow (`android-ci.yml`) includes the following jobs:

1. **Lint**: Runs ktlint and Android lint to ensure code quality
2. **Dependency Check**: Scans for vulnerable dependencies
3. **Unit Test**: Runs unit tests on the JVM
4. **Instrumented Test**: Runs UI tests on an Android emulator
5. **Build**: Builds the app for testing purposes

This workflow runs on pull requests and pushes to main and develop branches, ensuring code quality before deployment.

### Internal Testing Deployment Workflow
The internal testing deployment workflow is triggered automatically when changes are merged to the develop branch:

1. Build the debug APK
2. Run tests to ensure quality
3. Deploy to Firebase App Distribution for internal testing
4. Notify the team about the new build

Example workflow excerpt:

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up JDK
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'
      - name: Build Debug APK
        run: |\
          cd src/android
          ./gradlew assembleDebug
      - name: Upload APK
        uses: actions/upload-artifact@v3
        with:
          name: app-debug
          path: src/android/app/build/outputs/apk/debug/app-debug.apk
  
  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download APK
        uses: actions/download-artifact@v3
        with:
          name: app-debug
          path: artifacts
      - name: Setup Firebase CLI
        run: npm install -g firebase-tools
      - name: Deploy to Firebase App Distribution
        run: |\
          firebase appdistribution:distribute artifacts/app-debug.apk \
            --app ${{ secrets.FIREBASE_APP_ID }} \
            --groups "testers" \
            --release-notes "Build from develop branch"
        env:
          FIREBASE_TOKEN: ${{ secrets.FIREBASE_TOKEN }}
```

### Production Deployment Workflow
The production deployment workflow requires manual approval and is typically triggered after successful testing:

1. Wait for approval from authorized team members
2. Build the release bundle
3. Run tests to ensure quality
4. Upload to Google Play
5. Create a GitHub release with release notes
6. Notify the team about the submission

Example workflow excerpt:

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up JDK
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'
      - name: Decode Keystore
        run: |\
          echo ${{ secrets.KEYSTORE_BASE64 }} | base64 -d > keystore/amira-release-key.keystore
      - name: Build Release Bundle
        run: |\
          cd src/android
          ./gradlew bundleRelease
        env:
          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
          KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}
      - name: Upload Bundle
        uses: actions/upload-artifact@v3
        with:
          name: app-release
          path: src/android/app/build/outputs/bundle/release/app-release.aab
  
  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download Bundle
        uses: actions/download-artifact@v3
        with:
          name: app-release
          path: artifacts
      - name: Setup Google Play Publisher
        uses: r0adkll/upload-google-play@v1 # @r0adkll version 1
        with:
          serviceAccountJsonPlainText: ${{ secrets.PLAY_SERVICE_ACCOUNT_JSON }}
          packageName: com.amirawellness
          releaseFiles: artifacts/app-release.aab
          track: production
          status: completed
          releaseNotes: |\
            en-US: ${{ github.event.inputs.release_notes }}
            es-ES: ${{ github.event.inputs.release_notes_es }}
```

### Environment Promotion
Code follows a promotion path through environments:

1. Development: Local builds during feature development
2. Internal Testing: Automatic deployment from `develop` branch to Firebase App Distribution
3. Beta Testing: Manual promotion to Google Play Beta track after internal testing
4. Production: Manual approval required for deployment to Google Play Production track

This process ensures proper validation before code reaches end users.

## Fastlane Configuration
Fastlane can be used to automate the build and deployment process, providing consistent and reliable deployments.

### Fastlane Setup
To set up Fastlane for Android deployment:

```bash
# Install Fastlane
gem install fastlane

# Initialize Fastlane in the Android project
cd src/android
fastlane init
```

This creates a `fastlane` directory with initial configuration files.

### Fastfile Structure
The Fastfile defines the automation lanes for different deployment scenarios:

```ruby
default_platform(:android)

platform :android do
  before_all do
    # Setup steps that run before any lane
  end

  desc "Run tests"
  lane :test do
    gradle(task: "test")
  end

  desc "Build debug APK"
  lane :build_debug do
    gradle(task: "assembleDebug")
  end

  desc "Deploy to Firebase App Distribution"
  lane :beta do
    gradle(task: "assembleDebug")
    firebase_app_distribution(
      app: ENV["FIREBASE_APP_ID"],
      groups: "testers",
      release_notes: "Beta build from fastlane"
    )
  end

  desc "Deploy to Google Play Beta track"
  lane :play_beta do
    gradle(
      task: "bundleRelease",
      properties: {
        "android.injected.signing.store.file" => ENV["KEYSTORE_PATH"],
        "android.injected.signing.store.password" => ENV["KEYSTORE_PASSWORD"],
        "android.injected.signing.key.alias" => ENV["KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["KEY_PASSWORD"],
      }
    )
    upload_to_play_store(
      track: "beta",
      aab: "../app/build/outputs/bundle/release/app-release.aab"
    )
  end

  desc "Deploy to Google Play Production track"
  lane :play_production do
    gradle(
      task: "bundleRelease",
      properties: {
        "android.injected.signing.store.file" => ENV["KEYSTORE_PATH"],
        "android.injected.signing.store.password" => ENV["KEYSTORE_PASSWORD"],
        "android.injected.signing.key.alias" => ENV["KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["KEY_PASSWORD"],
      }
    )
    upload_to_play_store(
      track: "production",
      aab: "../app/build/outputs/bundle/release/app-release.aab"
    )
  end
end
```

This Fastfile defines lanes for testing, building, and deploying the app to different environments.

### Appfile Configuration
The Appfile contains app-specific information for fastlane:

```ruby
json_key_file(ENV["PLAY_STORE_JSON_KEY_PATH"]) # Path to the json secret file - Follow https://docs.fastlane.tools/actions/supply/#setup to get one
package_name("com.amirawellness") # e.g. com.krausefx.app
```

This information is used by fastlane to interact with Google Play.

### Using Fastlane with CI/CD
Fastlane can be integrated with GitHub Actions:

```yaml
- name: Setup Ruby
  uses: ruby/setup-ruby@v1 # @ruby version 1
  with:
    ruby-version: '3.2'
    bundler-cache: true

- name: Install Fastlane
  run: gem install fastlane

- name: Deploy to Firebase
  run: |\
    cd src/android
    fastlane beta
  env:
    FIREBASE_APP_ID: ${{ secrets.FIREBASE_APP_ID }}
    FIREBASE_TOKEN: ${{ secrets.FIREBASE_TOKEN }}
```

This allows you to use the same deployment scripts locally and in CI/CD.

## Google Play Submission
Submitting the app to Google Play involves several steps beyond building and uploading the binary.

### Google Play Console Setup
Before the first submission, the app must be properly configured in Google Play Console:

1. Create the app in Google Play Console with the correct package name
2. Configure app information (name, description, screenshots, etc.)
3. Complete the Data Safety section
4. Set up pricing and availability
5. Configure in-app purchases (if applicable)

These steps are typically performed manually through the Google Play Console web interface.

### App Bundles vs APKs
Google Play now prefers Android App Bundles (AAB) over APKs:

- **APK**: Traditional Android package format
- **AAB**: New format that generates optimized APKs for each device

Benefits of using AAB:
- Smaller download size for users
- Dynamic feature delivery
- Play Asset Delivery for large assets
- Easier management of multiple APKs

To build an AAB:

```bash
./gradlew bundleRelease
```

The output is located at `app/build/outputs/bundle/release/app-release.aab`.

### Play Store Listing
The Play Store listing requires several assets:

- App icon (512x512 PNG)
- Feature graphic (1024x500 PNG)
- Screenshots (various sizes for different devices)
- Short description (80 characters max)
- Full description (4000 characters max)
- Release notes for each version

These assets should be prepared in both English and Spanish (the app's primary language).

### Phased Rollout
For production releases, a phased rollout is recommended to gradually release to users:

1. In Google Play Console, select "Release dashboard"
2. Choose "Production" track
3. Create a new release
4. Upload the AAB file
5. Set the rollout percentage (e.g., start with 10%)
6. Submit for review

A phased rollout allows for early detection of issues before affecting all users. The rollout percentage can be increased gradually as confidence in the release grows.

### Play Store API
The Google Play Developer API can be used to automate app management:

1. Create a service account in Google Cloud Console
2. Grant it access to your Play Console account
3. Download the JSON key file
4. Use the key with fastlane or custom scripts

This API key can be used with fastlane actions like `upload_to_play_store` to interact with Google Play programmatically.

## Release Management
Proper release management ensures smooth updates and clear communication about changes.

### Version Numbering
The application follows semantic versioning (MAJOR.MINOR.PATCH) with an additional version code:

```kotlin
// In build.gradle.kts
android {
    defaultConfig {
        versionCode = 42 // Incremental integer
        versionName = "1.2.3" // Semantic version
    }
}
```

- versionName: Human-readable version following semantic versioning
  - MAJOR: Significant changes that may not be backward compatible
  - MINOR: New features that are backward compatible
  - PATCH: Bug fixes and minor improvements
- versionCode: Integer that increases with each release (used by Google Play)

The version code should be incremented for every release, even for the same version name.

### Release Notes
Release notes are generated automatically from git commits, but should be reviewed and edited before submission:

```bash
# Generate release notes
git log --pretty=format:"- %s" $(git describe --tags --abbrev=0)..HEAD
```

Release notes should be concise, user-focused, and highlight new features, improvements, and bug fixes. They should be written in Spanish (the app's primary language) and English, following a consistent format.

### Git Tagging
Each release is tagged in git for future reference:

```bash
# Tag the release (done automatically by the release workflow)
git tag -a v1.2.3 -m "Version 1.2.3"
git push origin v1.2.3
```

Tags follow the format `v{version}` (e.g., `v1.2.3`) and include the full version number.

### GitHub Releases
GitHub Releases provide a centralized place to document changes and provide release artifacts:

```bash
# Create a GitHub release (done by the CI/CD pipeline)
github release create v1.2.3 --title "Version 1.2.3" --notes "$(git log --pretty=format:'- %s' v1.2.2..HEAD)"
```

GitHub Releases are created automatically by the CI/CD pipeline after successful Google Play submission.

### Hotfix Process
For critical issues requiring immediate fixes:

1. Create a hotfix branch from the production tag: `git checkout -b hotfix/1.2.4 v1.2.3`
2. Fix the issue with minimal changes
3. Test thoroughly
4. Increment the patch version and version code
5. Create a pull request to the main branch
6. After approval, merge and tag the release
7. Deploy to Google Play with expedited review if necessary
8. Merge the changes back to the develop branch

This process ensures that critical fixes can be deployed quickly while maintaining the integrity of the codebase.

## Troubleshooting
Common deployment issues and their resolution procedures.

### Build Issues
For build failures:

1. Check the build log for specific error messages
2. Verify that dependencies are up to date: `./gradlew dependencies`
3. Clean the build folder: `./gradlew clean`
4. Check for Kotlin version compatibility issues
5. Verify that all required files are included in the project

Common build issues include:
- Dependency conflicts: Check for version incompatibilities
- Gradle plugin version mismatches: Ensure Android Gradle Plugin and Kotlin plugin versions are compatible
- Resource errors: Check for invalid resource files or references
- ProGuard/R8 issues: Review ProGuard rules for any problematic configurations

### Signing Issues
For signing issues:

1. Verify that the keystore file exists and is accessible
2. Check that the keystore password and key alias are correct
3. Ensure that the signing configuration is properly set up in the build file
4. Verify that the environment variables are correctly set in CI/CD

If you need to verify keystore information:

```bash
keytool -list -v -keystore keystore/amira-release-key.keystore
```

This will prompt for the keystore password and display information about the keys in the keystore.

### Google Play Rejection
For Google Play rejection:

1. Carefully read the rejection reason in Google Play Console
2. Address the specific issues mentioned by the reviewer
3. Test the fixes thoroughly before resubmitting
4. Consider contacting Google Play support if the rejection seems incorrect
5. Update the app metadata if it doesn't match the app functionality

Common rejection reasons include:
- Data safety section issues
- Policy violations
- Crash on startup or during testing
- Performance problems
- Metadata inconsistencies

### Firebase App Distribution Issues
For Firebase App Distribution issues:

1. Verify that the Firebase project is correctly set up
2. Check that the app is registered in Firebase with the correct package name
3. Ensure that the Firebase token is valid and has the necessary permissions
4. Verify that testers are properly added to the distribution groups

If uploads fail, check the Firebase CLI output for specific error messages.

### CI/CD Pipeline Issues
For CI/CD pipeline issues:

1. Check the GitHub Actions workflow logs for specific error messages
2. Verify that all required secrets are properly configured
3. Ensure that the workflow file is correctly formatted
4. Check for changes in GitHub Actions or external service APIs

Common CI/CD issues include:
- Missing or incorrect secrets
- Expired tokens or credentials
- Changes in external service APIs
- Resource limitations in GitHub Actions runners

## Security Considerations
Security is a primary concern for the Amira Wellness application, with specific considerations for Android deployment.

### Keystore Security
The signing keystore must be protected:

- Never commit the keystore file to the repository
- Store the keystore file in a secure location with restricted access
- Use strong, unique passwords for the keystore and key
- Consider using a hardware security module for key storage
- Create a secure backup of the keystore file

Loss of the keystore would prevent updates to the existing app on Google Play, requiring a new app listing.

### Credentials Management
Sensitive credentials are stored securely:

- Local development: Environment variables or local.properties (not committed)
- CI/CD pipeline: GitHub Secrets with appropriate access controls
- Google Play API: Service account keys stored securely and rotated regularly

Credentials are never committed to the repository, even in encrypted form.

### Sensitive Configuration
Sensitive configuration is handled securely:

- API keys and secrets are not hardcoded in the app
- Environment-specific configuration is injected during build
- Production credentials are only used in production builds
- Debug features are disabled in production builds

This approach prevents leakage of sensitive information through the app binary.

### End-to-End Encryption
The app implements end-to-end encryption for sensitive user data:

- Voice recordings are encrypted on the device before transmission
- Encryption keys are stored in the Android Keystore where available
- Key material is never transmitted to the server
- Biometric authentication can be used to protect access to encrypted data

This ensures that sensitive user data remains private and secure throughout the application lifecycle.

### Code Obfuscation
Release builds use R8 for code obfuscation and optimization:

```kotlin
android {
    buildTypes {
        release {
            isMinifyEnabled = true
            isShrinkResources = true
            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
        }
    }
}
```

Custom ProGuard rules in `proguard-rules.pro` ensure that essential code is not obfuscated while protecting sensitive implementation details.

## References

### Internal Documentation
- [Android README](../../src/android/README.md): Overview of the Android application
- [Backend Deployment](./backend-deployment.md): Backend deployment procedures
- [Security Architecture](../architecture/security.md): Security implementation details
- [Development Setup](../development/setup.md): Local development environment

### External Resources
- [Google Play Console Help](https://support.google.com/googleplay/android-developer/): Official documentation for Google Play Console
- [Firebase App Distribution](https://firebase.google.com/docs/app-distribution): Firebase documentation for app distribution
- [Fastlane Documentation](https://docs.fastlane.tools/): Comprehensive guide to fastlane
- [Android Developer Documentation](https://developer.android.com/): Official Android developer resources

### Tools and Scripts
- `scripts/version-bump.sh`: Helper script for version management
- `scripts/generate-release-notes.sh`: Script for generating release notes
- `scripts/validate-build.sh`: Build validation script
- `scripts/localization-helper.py`: Localization management script

## Appendix
Additional reference information for Android deployment.

### Gradle Commands Reference
Common Gradle commands used in the deployment process:

```bash
# Clean the project
./gradlew clean

# Run tests
./gradlew test

# Run lint checks
./gradlew lint

# Build debug APK
./gradlew assembleDebug

# Build release APK
./gradlew assembleRelease

# Build release bundle
./gradlew bundleRelease

# Install debug APK on connected device
./gradlew installDebug

# Run instrumented tests
./gradlew connectedAndroidTest

# Generate dependency reports
./gradlew dependencies
```

These commands can be run locally or in the CI/CD pipeline.

### Environment Variables
Environment variables used in the deployment process:

| Variable | Purpose | Used In |
|----------|---------|--------|
| `KEYSTORE_PASSWORD` | Password for the keystore file | Gradle, Fastlane |
| `KEY_ALIAS` | Alias of the signing key | Gradle, Fastlane |
| `KEY_PASSWORD` | Password for the signing key | Gradle, Fastlane |
| `KEYSTORE_PATH` | Path to the keystore file | Gradle, Fastlane |
| `PLAY_SERVICE_ACCOUNT_JSON` | JSON key for Google Play service account | Fastlane |
| `FIREBASE_APP_ID` | Firebase App ID for distribution | Firebase CLI, Fastlane |
| `FIREBASE_TOKEN` | Firebase CLI authentication token | Firebase CLI, Fastlane |

These variables should be set in the CI/CD environment or locally as needed.

### Google Play Developer API Setup
Steps to set up a Google Play Developer API service account:

1. Go to the Google Play Console
2. Navigate to Setup > API access
3. Create a new service account in the Google Cloud Console
4. Grant the service account the necessary permissions
5. Create and download a JSON key file
6. Store the key file securely
7. Use the key with fastlane or custom scripts:

```ruby
json_key_file("path/to/key.json")
package_name("com.amirawellness")
```

This approach is more secure than using Google account credentials.

### Firebase App Distribution Groups
Firebase App Distribution allows organizing testers into groups:

1. Go to the Firebase Console
2. Select your project
3. Navigate to App Distribution
4. Select your app
5. Go to Testers & Groups
6. Create groups for different testing purposes (e.g., "Developers", "QA", "Stakeholders")

To distribute to specific groups with the Firebase CLI:

```bash
firebase appdistribution:distribute app/build/outputs/apk/debug/app-debug.apk \
  --app [FIREBASE_APP_ID] \
  --groups "developers,qa" \
  --release-notes "Internal testing build"
```

This allows for targeted distribution to specific tester groups.

### APK Signing Verification
To verify the signing of an APK:

```bash
# Using apksigner (part of Android SDK)
apksigner verify --verbose app/build/outputs/apk/release/app-release.apk

# Using jarsigner (part of JDK)
jarsigner -verify -verbose -certs app/build/outputs/apk/release/app-release.apk
```

This helps confirm that the APK is correctly signed with the expected certificate.